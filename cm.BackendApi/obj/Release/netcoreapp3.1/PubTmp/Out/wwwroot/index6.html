<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title></title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="robots" content="noindex, nofollow">
    <meta name="googlebot" content="noindex, nofollow">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script type="text/javascript"
            src="./js/lib/dummy.js"></script>

    <link rel="stylesheet" type="text/css" href="./css/result-light.css">

    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3&amp;libraries=drawing"></script>

    <style id="compiled-css" type="text/css">
        html, body, table {
            height: 100%;
            width: 100%;
            margin: 0px;
            padding: 0px
        }

        td {
            width: 50%;
            height: 100%;
            padding: 0;
        }

            td > div {
                height: 100%;
            }

        th {
            height: 20px;
        }

        /* EOS */
    </style>
</head>
<body>
    <table border="1">
        <tr>
            <th>add some features  then run the test</th>
            <th>test-result</th>
        </tr>
        <tr>
            <td><div></div></td>
            <td><div></div></td>
        </tr>
    </table>

    <script type="text/javascript">
//<![CDATA[

function initialize() {
  // Create a simple map.
  map = new google.maps.Map(document.getElementsByTagName('TD')[0].firstChild, {
    zoom: 4,
    center: {lat: -28, lng: 137.883},
    disableDefaultUI:true
  });
  map2 = new google.maps.Map(document.getElementsByTagName('TD')[1].firstChild, {
    zoom: map.getZoom(),
    center: map.getCenter()
  });
  map2.bindTo('zoom',map,'zoom');
  map2.bindTo('center',map,'center');
  map.data.setStyle(function(feature) {
    if(feature.getProperty('radius') && feature.getGeometry().getType()==='Point'){
        return {
        visible:false
      };
    }

    return {

    };
});
  map2.data.setStyle(function(feature) {
    if(feature.getProperty('radius') && feature.getGeometry().getType()==='Point'){

    new google.maps.Circle({map:map2,center:feature.getGeometry().get(),radius:feature.getProperty('radius')});
        return {
        visible:false
      };
    }

    return {

    };
});

  map.data.loadGeoJson('https://storage.googleapis.com/maps-devrel/google.json');

  google.maps.event.addListenerOnce(map.data,'addfeature',function(){
    var btn=document.createElement('input');
    btn.type='button';
    btn.value='click here to test the geoJson-export in the right map';
    google.maps.event.addDomListener(btn,'click',function(){
      map2.data.forEach(function(f){map2.data.remove(f);});
      map.getGeoJson(function(geo){console.log(map2.data.addGeoJson(geo));});
    });
    map.controls[google.maps.ControlPosition.TOP_RIGHT].push(btn);

  });
  var drawingManager = new google.maps.drawing.DrawingManager({
  map:map,
  drawingMode: google.maps.drawing.OverlayType.MARKER,
  drawingControl: true,
  drawingControlOptions: {
    position: google.maps.ControlPosition.RIGHT_TOP,
    drawingModes: [
      google.maps.drawing.OverlayType.MARKER,
      google.maps.drawing.OverlayType.POLYGON,
      google.maps.drawing.OverlayType.POLYLINE,
      google.maps.drawing.OverlayType.CIRCLE,
      google.maps.drawing.OverlayType.RECTANGLE
    ]
  }
});

google.maps.event.addListener(drawingManager, 'overlaycomplete', function(event) {
  switch(event.type){
      case google.maps.drawing.OverlayType.MARKER:
        map.data.add(new google.maps.Data.Feature({geometry:new google.maps.Data.Point(event.overlay.getPosition())}));
        console.log(new google.maps.Data.Feature({geometry:new google.maps.Data.Point(event.overlay.getPosition())}))
        break;
      case google.maps.drawing.OverlayType.RECTANGLE:
        var b=event.overlay.getBounds(),
            p=[b.getSouthWest(),{lat:b.getSouthWest().lat(),lng:b.getNorthEast().lng()},b.getNorthEast(),{lng:b.getSouthWest().lng(),lat:b.getNorthEast().lat()}]
        map.data.add(new google.maps.Data.Feature({geometry:new google.maps.Data.Polygon([p])}));
        break;
      case google.maps.drawing.OverlayType.POLYGON:
        map.data.add(new google.maps.Data.Feature({geometry:new google.maps.Data.Polygon([event.overlay.getPath().getArray()])}));
        console.log(new google.maps.Data.Feature({geometry:new google.maps.Data.Polygon([event.overlay.getPath().getArray()])}))
        break;
      case google.maps.drawing.OverlayType.POLYLINE:
        map.data.add(new google.maps.Data.Feature({geometry:new google.maps.Data.LineString(event.overlay.getPath().getArray())}));
        console.log(new google.maps.Data.Feature({geometry:new google.maps.Data.LineString(event.overlay.getPath().getArray())}))
        break;
      case google.maps.drawing.OverlayType.CIRCLE:
        map.data.add(new google.maps.Data.Feature({properties:{radius:event.overlay.getRadius()},geometry:new google.maps.Data.Point(event.overlay.getCenter())}));
        break;
  }

});

}

google.maps.Map.prototype.getGeoJson=function(callback){
  var geo={"type": "FeatureCollection","features": []},
      fx=function(g,t){

        var that  =[],
            arr,
            f     = {
                      MultiLineString :'LineString',
                      LineString      :'Point',
                      MultiPolygon    :'Polygon',
                      Polygon         :'LinearRing',
                      LinearRing      :'Point',
                      MultiPoint      :'Point'
                    };

        switch(t){
          case 'Point':
            g=(g.get)?g.get():g;
            return([g.lng(),g.lat()]);
            console.log([g.lng(),g.lat()])
            break;
          default:
            arr= g.getArray();
            for(var i=0;i<arr.length;++i){
              that.push(fx(arr[i],f[t]));
            }
            if( t=='LinearRing'
                  &&
                that[0]!==that[that.length-1]){
              that.push([that[0][0],that[0][1]]);
            }
            return that;
        }
      };

  this.data.forEach(function(feature){
   var _feature     = {type:'Feature',properties:{}}
       _id          = feature.getId(),
       _geometry    = feature.getGeometry(),
       _type        =_geometry.getType(),
       _coordinates = fx(_geometry,_type);

       _feature.geometry={type:_type,coordinates:_coordinates};
       if(typeof _id==='string'){
        _feature.id=_id;
       }

       geo.features.push(_feature);
       feature.forEachProperty(function(v,k){
          _feature.properties[k]=v;
       });
  });
  if(typeof callback==='function'){
    callback(geo);
  }
  return geo;
}

google.maps.event.addDomListener(window, 'load', initialize);

  //]]></script>

    <script>
    // tell the embed parent frame the height of the content
    if (window.parent && window.parent.parent){
      window.parent.parent.postMessage(["resultsFrame", {
        height: document.body.getBoundingClientRect().height,
        slug: ""
      }], "*")
    }

    // always overwrite window.name, in case users try to set it manually
    window.name = "result"
    </script>

    <script>
      let allLines = []

      window.addEventListener("message", (message) => {
        if (message.data.console){
          let insert = document.querySelector("#insert")
          allLines.push(message.data.console.payload)
          insert.innerHTML = allLines.join(";\r")

          let result = eval.call(null, message.data.console.payload)
          if (result !== undefined){
            console.log(result)
          }
        }
      })
    </script>
</body>
</html>